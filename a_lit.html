<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Literature</title>
    <!-- icon -->
    <link rel="icon" href="./img/attent.ico" />
    <!-- css -->
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <!-- Webfont -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="./fontawesome/css/all.css" rel="stylesheet">
</head>

<body>

    <header id="top">
        <nav>
            <a href="index.html">The Attention System (ATS)</a>
            <a href="a_alr.html">Alerting</a>
            <a href="a_ort.html">Orienting</a>
            <a href="a_exe.html">Executive</a>
            <a href="a_ext.html">Extending the ATS-Framework</a>
            <a href="#">Literature</a>
            <a href="a_wks.html" target="_blank">Attention Training Workshop</a>
        </nav>
        <h1><i class="fa fa-brain"></i> Literature</h1>
    </header>
    <main>
        Here is complex.cpp:
<pre><code>
#include <cstdio>

#include "complex.hpp"

// x+iy + (x'+iy') = (x+x') + i (y+y')
Complex add(Complex a, Complex b) {
  Complex c;
  c.im = a.im + b.im;
  c.re = a.re + b.re;
  return c;
}

// (x+iy) * (x'+iy') = xx' - yy' + i (xy' +x'y)
Complex mult(Complex a, Complex b) {
  Complex c;
  c.re = a.re * b.re - a.im * b.im;
  c.im = a.re * b.im + a.im * b.re;
  return c;
}

// -(x+iy) = -x + i*(-y)
Complex unary_minus(Complex a) {
  Complex c;
  c.re = -a.re;
  c.im = -a.im;
  return c;
}

bool equal(Complex a, Complex b) { return (a.re == b.re) && (a.im == b.im); }

// (x+iy) / (x'+iy') = (x+iy) * (x'-iy') / (x'^2 - y'^2)
// = (xx' + yy') / (x'^2 - y'^2) + i * (-xy' + x'y) / (x'^2 - y'^2)
Complex div(Complex a, Complex b) {
  Complex c;
  const double norm = (b.re * b.re + b.im * b.im);
  c.re = (a.re * b.re + a.im * b.im) / norm;
  c.im = (-a.re * b.im + a.im * b.re) / norm;
  return c;
}

// 1/ (x+iy) = (x-iy) / (x^2 - y^2)
Complex inverse(Complex a) {
  Complex c;
  const double norm = (a.re * a.re + a.im * a.im);
  c.re = a.re / norm;
  c.im = -a.im / norm;
  return c;
}

void print(Complex a) { printf("%f +i * %f\n", a.re, a.im); }

double norm2(Complex a) { return (a.re * a.re + a.im * a.im); }

Complex minus(Complex a, Complex b) { return add(a, unary_minus(b)); }
</code></pre>
Here is image.cpp:
<pre><code>
#include <cstdio>
#include <stdlib.h>

#include "image.hpp"
#include "newton.hpp"

void print_image(const char *filename, int *frac, int x_max, int y_max) {
  FILE *fp = fopen(filename, "w");
  if (!fp)
    exit(-1);

  const char *comment = "# file created by Mathias Fleury";

  fprintf(fp, "P3\n %s\n %d\n %d\n 255\n", comment, x_max, y_max);

  for (int y = 0; y < y_max; ++y) {
    for (int x = 0; x < x_max; ++x) {
      fprintf(fp, "%d %d %d ", (unsigned char)frac[y * x_max * 3 + x * 3 + 0],
              (unsigned char)frac[y * x_max * 3 + x * 3 + 1],
              (unsigned char)frac[y * x_max * 3 + x * 3 + 2]);
    }
    fprintf(fp, "\n");
  }

  fclose(fp);
}</code></pre>
Here is mainImage.cpp:
<pre><code>
#include <complex>
#include <iostream>

#include "complex.hpp"
#include "image.hpp"
#include "newtonfractal.hpp"

int main() {
  // NB: it is important to change both values at the same time if you increase
  // the number of iterations make the precision close to zero. Remember than
  // Newton's method converges _fast_.
  const int max_iterations = 30;
  const double precision = 0.0001;

  // default values for poly1
  const double x_start = -2.5;
  const double x_end = 2.5;
  const double x_step = 0.01;
  const double y_start = -5;
  const double y_end = 5;
  const double y_step = 0.01;

  // // default values for poly2
  // // which you can get by running
  // make EXCLUDED=poly.cpp
  // const double x_start = -3;
  // const double x_end = 5;
  // const double x_step = 0.01;
  // const double y_start = -10;
  // const double y_end = 3;
  // const double y_step = 0.01;

  const int x_size = (x_end - x_start) / x_step;
  const int y_size = (y_end - y_start) / y_step;

  int *frac = newton_fractal(x_start, x_step, x_end, y_start, y_step, y_end,
                             max_iterations, precision);
  print_image("newton.ppm", frac, x_size, y_size);
  free(frac);

  return 0;
}</code></pre>
Here is newton.cpp:
<pre><code>
#include <cstdio>

#include "newton.hpp"
#include "poly.hpp"

Complex next_value(Complex z) {
  Complex x = div(poly(z), derived_poly(z));
  return minus(z, x);
}

Solution converges_to(Complex z, double precision, int max_iterations) {
  bool finished = false;
  int root = 0, i;

  for (i = 0; i < max_iterations && !finished; ++i, z = next_value(z)) {
    root = classify_root(z, precision);
    finished = (root != 0);
  }

  return {root, i};
}
</code></pre>
Here is newtonfractal.cpp:
<pre><code>
#include "newton.hpp"
#include <cstdio>
#include <cstdlib>

int *newton_fractal(double x_start, double x_step, double x_end, double y_start,
                    double y_step, double y_end, int max_iterations,
                    double precision) {
  const int x_size = (x_end - x_start) / x_step;
  const int y_size = (y_end - y_start) / y_step;

  int *frac = (int *)malloc(y_size * x_size * 3 * sizeof(int));

  for (int i = 0; i < y_size; ++i) {
    for (int j = 0; j < x_size; ++j) {
      const Complex starting_point = {
          x_start + j * x_step,
          y_start + i * y_step,
      };

      Solution sol = converges_to(starting_point, precision, max_iterations);
      int color =
          static_cast<int>(((double)max_iterations - sol.number_of_iterations) /
                           (double)max_iterations * (double)255);

      // we give name to the different colors to make
      // the code clear.
      const int offset = i * x_size * 3 + j * 3;
      int *red = &frac[offset + 0];
      int *green = &frac[offset + 1];
      int *blue = &frac[offset + 2];
      *red = 0;
      *green = 0;
      *blue = 0;
      switch (sol.sol_number) {
      case 1:
        *red = color;
        break;
      case 2:
        *green = color;
        break;
      case 3:
        *blue = color;
        break;
      default:
        break;
      }
    }
  }

  return frac;
}</code></pre>
Here is poly.cpp:
<pre><code>
#include <cstdio>
#include <math.h>

#include "poly.hpp"

// direct calculation
Complex poly(Complex z) {
  Complex z3 = mult(mult(z, z), z);
  Complex one{1, 0};
  return minus(z3, one);
}

// direct calculation
Complex derived_poly(Complex z) {
  Complex three{3, 0};
  Complex z2 = mult(z, z);
  Complex z3 = mult(z2, three);
  return z3;
}

// We use the squared norm instead of taking the square root.
// Therefore, we square the precision.
int classify_root(Complex a, double precision) {
  const Complex z1{1, 0};
  const Complex z2{-.5, sqrt(3) / 2.};
  const Complex z3{-.5, -sqrt(3) / 2.};

  if (norm2(minus(a, z1)) < precision * precision)
    return 1;
  if (norm2(minus(a, z2)) < precision * precision)
    return 2;
  if (norm2(minus(a, z3)) < precision * precision)
    return 3;
  return 0;
}
</code></pre>
Here is complex.hpp:
<pre><code>
#ifndef BLATT_03_COMPLEX
#define BLATT_03_COMPLEX

  // very simple modelisation of complex numbers with a real part and an imaginary part. We put into
  // a namespace to avoid issue with std::equal...
struct Complex {
  double re;
  double im;
};

  /// check for equality of 2 complex numbers
bool equal (Complex, Complex);

  /// multiply two complex numbers
Complex mult (Complex, Complex);

  /// divides two complex numbers. The second should not be zero.
Complex div (Complex, Complex);

  /// addition of two complex numbers
Complex add (Complex, Complex);

// -z
Complex unary_minus (Complex);

  /// inverse of complex numbers. The argument should not be zero.
Complex inverse (Complex);

  /// Prints a complex number with a line break
void print (Complex);

  // square absolute value
double norm2 (Complex);

// subtraction of two complex numbers
Complex minus (Complex, Complex);

#endif</code></pre>
Here is image.hpp:
<pre><code>
#pragma once

// write a PPM image from the pixel matrix with the given size.
//
// It does not free the array representing the image.
void print_image (const char *, int*, int, int);</code></pre>
Here is newton.hpp:
<pre><code>
#ifndef BLATT_04_NEWTON
#define BLATT_04_NEWTON

#include "complex.hpp"

// Structure representing the result of applying Newton's procedure. It contains to which solution
// the procedure converged to and the number of iterations that was required.
struct Solution {
  int sol_number;
  int number_of_iterations;
};

// Newton procedure to find root starting at z, until the precision is reached
// or we run of iterals
Solution converges_to (Complex z, double precision, int max_iterations);

#endif</code></pre>
Here is newtonfractal.hpp:
<pre><code>
#ifndef BLATT_04_NEWTONFRACTAL
#define  LATT_04_NEWTONFRACTAL

// calculate the fractal in the interval [x_start, x_end] and [y_start, y_end] with the step x_step
// and y_step.  Roots are approached when close enough (<= precision) with an upper bound on the
// number of iterations
int* newton_fractal(double x_start, double x_step, double x_end,
		    double y_start, double y_step, double y_end,
		    int max_iterations, double precision);

#endif</code></pre>
Here is poly.hpp:
<pre><code>
#pragma once

#include "complex.hpp"

Complex poly (Complex);
Complex derived_poly (Complex);
int classify_root (Complex a, double precision);</code></pre>

Here is Makefile:
<pre><code> 
CXX = g++
CXXFLAGS = -std=c++14
EXCLUDED = poly2.cpp
HEADERS = $(filter-out $(EXCLUDED), $(wildcard *.hpp))
OBJECTS = $(addsuffix .o, $(basename  $(filter-out $(EXCLUDED) complextest.cpp main.cpp, $(wildcard *.cpp))))

all: clean compile

%.o: %.cpp $(HEADERS)
	$(CXX) $(CXXFLAGS) -c $< -lgtest -lpthread

%Main: %.o $(OBJECTS)
	$(CXX) $(CXXFLAGS) -o $@ $^

compile: imageMain

test: complextest.cpp $(OBJECTS)
	$(CXX) $(CXXFLAGS) -o complextest $^ -lgtest -lpthread
	./complextest

clean:
	rm -f imageMain *.o *.ppm

format:
	clang-format -i *.cpp
</code></pre>
    </main>
</body>

</html>