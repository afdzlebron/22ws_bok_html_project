<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Literature</title>
    <!-- icon -->
    <link rel="icon" href="./img/attent.ico" />
    <!-- css -->
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <!-- Webfont -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="./fontawesome/css/all.css" rel="stylesheet">
</head>

<body>

    <header id="top">
        <nav>
            <a href="index.html">The Attention System (ATS)</a>
            <a href="a_alr.html">Alerting</a>
            <a href="a_ort.html">Orienting</a>
            <a href="a_exe.html">Executive</a>
            <a href="a_ext.html">Extending the ATS-Framework</a>
            <a href="#">Literature</a>
            <a href="a_wks.html" target="_blank">Attention Training Workshop</a>
        </nav>
        <h1><i class="fa fa-brain"></i> Literature</h1>
    </header>
    <main>
        Here is complex.hpp:
        <pre><code>
            #ifndef COMPLEX_H
            #define COMPLEX_H
            
            struct Complex {
              double re;
              double im;
            };
            
            bool equal(Complex a, Complex b);
            Complex mult(Complex a, Complex b);
            Complex div(Complex a, Complex b);
            Complex add(Complex a, Complex b);
            Complex inverse(Complex z);
            Complex sub(Complex a, Complex b);
            void print(Complex z);
            
            #endif // COMPLEX_H
            
            </code></pre>

        Here is complex.cpp:
        <pre><code>
            #include "complex.hpp"

            #include <cmath>
            #include <cstdio>

            bool equal(Complex a, Complex b) { return (a.re == b.re) && (a.im == b.im); }

            Complex mult(Complex a, Complex b) {
            Complex result;
            result.re = a.re * b.re - a.im * b.im;
            result.im = a.re * b.im + a.im * b.re;
            if (std::isnan(result.re) && std::isnan(result.im)) {
                result.re = 0;
                result.im = 0;
            }
            return result;
            }

            Complex div(Complex a, Complex b) {
            double div = b.re * b.re + b.im * b.im;
            Complex result;
            result.re = (a.re * b.re + a.im * b.im) / div;
            result.im = (a.im * b.re - a.re * b.im) / div;
            if (std::isnan(result.re) && std::isnan(result.im)) {
                result.re = 0;
                result.im = 0;
            }
            return result;
            }

            Complex add(Complex a, Complex b) {
            Complex result;
            result.re = a.re + b.re;
            result.im = a.im + b.im;
            if (std::isnan(result.re) && std::isnan(result.im)) {
                result.re = 0;
                result.im = 0;
            }
            return result;
            }

            Complex inverse(Complex z) {
            double div = z.re * z.re + z.im * z.im;
            Complex result;
            result.re = z.re / div;
            result.im = -z.im / div;
            if (std::isnan(result.re) && std::isnan(result.im)) {
                result.re = 0;
                result.im = 0;
            }
            return result;
            }

            Complex sub(Complex a, Complex b) {
            Complex result;
            result.re = a.re - b.re;
            result.im = a.im - b.im;
            if (std::isnan(result.re) && std::isnan(result.im)) {
                result.re = 0;
                result.im = 0;
            }
            return result;
            }

            void print(Complex z) { printf("(%g + %gi)", z.re, z.im); }
        </code></pre>

        Here is poly.hpp:
        <pre><code>
        #ifndef POLYNOM_H
        #define POLYNOM_H

        #include "complex.hpp"

        class Polynom {
        public:
        Complex poly(Complex z);
        Complex derived_poly(Complex z);
        };

        #endif  // POLYNOM_H

        </code></pre>
        Here is poly.cpp:
        <pre><code>
            #include "poly.hpp"

            #include <cmath>
            #include <cstdio>
            
            #include "complex.hpp"
            
            
            
            Complex Polynom::poly(Complex z) {
              // Define the polynomial to evaluate at z
              // For example, z^3 - 1
              Complex minus_one = {-1, 0};
              Complex result = mult(z, mult(z, z));
              result = add(result, minus_one);
              if (std::isnan(result.re) && std::isnan(result.im)) {
                result.re = 0;
                result.im = 0;
              }
              return result;
            }
            
            Complex Polynom::derived_poly(Complex z) {
              // Define the derivative of the polynomial to evaluate at z
              // For example, the derivative of z^3 - 1 is 3z^2
              Complex three = {3, 0};
              Complex result = mult(three, mult(z, z));  // 3*z^2
              if (std::isnan(result.re) && std::isnan(result.im)) {
                result.re = 0;
                result.im = 0;
              }
              return result;
            }
        </code></pre>
        Here is image.hpp:
        <pre><code>
            #ifndef IMAGE_HPP
            #define IMAGE_HPP
            
            #include <cstdio>
            
            class Image {
             public:
              Image(int width, int height);
              ~Image();
              void update_pixel(int x, int y, int r, int g, int b);
              int* get_image_data();
              void write(const char* filename);
            
             private:
              int* image;
              int width;
              int height;
            };
            
            #endif /* IMAGE_HPP */
        </code></pre>
        Here is image.cpp:
        <pre><code>
            #include "image.hpp"

            #include <cmath>
            #include <cstdio>
            #include <cstdlib>
            #include <stdexcept>
            
            #include "complex.hpp"
            #include "poly.hpp"
            
            Image::Image(int width, int height) : width(width), height(height) {
              image = new int[width * height * 3];
            }
            
            Image::~Image() { delete[] image; }
            
            // void Image::update_pixel(int x, int y, int r, int g, int b) {
            //   image[(y * width + x) * 3] = r;
            //   image[(y * width + x) * 3 + 1] = g;
            //   image[(y * width + x) * 3 + 2] = b;
            // }
            
            
            void Image::update_pixel(int x, int y, int r, int g, int b) {
              if (x < 0 || x >= width || y < 0 || y >= height) {
                throw std::out_of_range("Pixel coordinates out of bounds");
              }
              image[(y * width + x) * 3] = r;
              image[(y * width + x) * 3 + 1] = g;
              image[(y * width + x) * 3 + 2] = b;
            }
            
            
            int* Image::get_image_data() { return image; }
            
            void Image::write(const char* filename) {
              FILE* fp = fopen(filename, "w");
              if (!fp) {
                fprintf(stderr, "could not open file %s", filename);
                exit(1);
              }
              const char* comment = "# file created by AFL";
              fprintf(fp, "P3\n %s\n %d\n %d\n 65535\n", comment, width, height);
            
              for (int y = height - 1; y >= 0; y--) {
                for (int x = 0; x < width; x++) {
                  fprintf(fp, "%d %d %d ", image[(y * width + x) * 3] * 257,
                          image[(y * width + x) * 3 + 1] * 257,
                          image[(y * width + x) * 3 + 2] * 257);
                }
                fprintf(fp, "\n");
              }
            
              fclose(fp);
            }

        </code></pre>
        Here is newton_fractal.hpp:
        <pre><code>
            #ifndef NEWTONFRACTAL_H
            #define NEWTONFRACTAL_H
            #include <cmath>
            
            #include "complex.hpp"
            #include "image.hpp"
            #include "poly.hpp"
            
            class NewtonFractal {
             public:
              Complex newtonMethod(Complex z);
              int nearRoot(Complex x, double precision);
              int classify_root(Complex z, double precision);
            
              NewtonFractal(double x_start, double x_step, double x_end, double y_start,
                            double y_step, double y_end, int max_iterations,
                            double precision);
            
              Image calculate();
            
             private:
              double x_start;
              double x_step;
              double x_end;
              double y_start;
              double y_step;
              double y_end;
              int max_iterations;
              double precision;
            };
            
            #endif  // NEWTONFRACTAL_H
        </code></pre>
        Here is newton_fractal.cpp:
        <pre><code>
            #include "newton_fractal.hpp"

            #include <cmath>
            
            #include "complex.hpp"
            #include "image.hpp"
            #include "poly.hpp"
            
            Complex NewtonFractal::newtonMethod(Complex z) {
              Polynom p;
              Complex x = z;
              Complex fx = p.poly(x);
              Complex fxPrime = p.derived_poly(x);
              Complex fraction = div(fx, fxPrime);
              x = sub(x, fraction);
              x = sub(x, fraction);
              return x;
            }
            
            int NewtonFractal::nearRoot(Complex x, double precision) {
              Complex roots[] = {{1, 0}, {-0.5, sqrt(3) / 2}, {-0.5, -sqrt(3) / 2}};
              double distance = precision * 2;
              for (int i = 0; i < 3; i++) {
                distance = sqrt((x.re - roots[i].re) * (x.re - roots[i].re) +
                                (x.im - roots[i].im) * (x.im - roots[i].im));
                if (distance <= precision) {
                  return i + 1;
                }
              }
              return 0;
            }
            
            int NewtonFractal::classify_root(Complex z, double precision) {
              Complex x = z;
              Complex roots[] = {{1, 0}, {0.5, sqrt(3) / 2}, {-0.5, -sqrt(3) / 2}};
              int calc = 0;
              int steps = 0;
              const int max_steps = 20;
            
              while (steps < max_steps) {
                x = newtonMethod(x);
                calc = nearRoot(x, precision);
                if (calc > 0) {
                  return calc;
                }
                steps++;
              }
              return 0;
            }
            
            NewtonFractal::NewtonFractal(double x_start, double x_step, double x_end,
                                         double y_start, double y_step, double y_end,
                                         int max_iterations, double precision)
                : x_start(x_start),
                  x_step(x_step),
                  x_end(x_end),
                  y_start(y_start),
                  y_step(y_step),
                  y_end(y_end),
                  max_iterations(max_iterations),
                  precision(precision) {}
            
            Image NewtonFractal::calculate() {
              int x_max = (x_end - x_start) / x_step;
              int y_max = (y_end - y_start) / y_step;
              Image img(x_max, y_max);
            
              for (int y = 0; y < y_max; y++) {
                for (int x = 0; x < x_max; x++) {
                  Complex z = {x_start + x * x_step, y_start + y * y_step};
                  int root = classify_root(z, precision);
                  if (root == 1) {
                    img.update_pixel(x, y, 0, 255, 0);
                  } else if (root == 2) {
                    img.update_pixel(x, y, 0, 0, 255);
                  } else if (root == 3) {
                    img.update_pixel(x, y, 255, 0, 0);
                  } else {
                    img.update_pixel(x, y, 0, 0, 0);
                  }
                }
              }
              return img;
            }
            
        </code></pre>

        Here is imageMain.cpp:
        <pre><code>
            // Copyright 2023, AFL
            #include <cmath>
            #include <cstdio>
            
            #include "complex.hpp"
            #include "image.hpp"
            #include "newton_fractal.hpp"
            #include "poly.hpp"
            
            int main() {
              int max_iterations = 100;
              double precision = 1e-3;
            
              double x_start = -3.0;
              double x_end = 3.0;
              double x_step = 0.01;
              double y_start = -3.0;
              double y_end = 3.0;
              double y_step = 0.01;
            
              int size_x = (x_end - x_start) / x_step;
              int size_y = (y_end - y_start) / y_step;
            
              NewtonFractal fractal(x_start, x_step, x_end, y_start, y_step, y_end,
                                    max_iterations, precision);
              Image img = fractal.calculate();
              img.write("newton_fractal.ppm");
            
              return 0;
            }
            
        </code></pre>
        Here is imageTest.cpp:
        <pre><code>
            #include "gtest/gtest.h"
            #include "image.hpp"
            
            
            TEST(ImageTest, UpdatePixel) {
              // Create an Image object with width 2 and height 2
              Image img(2, 2);
            
              // Update the pixel at position (0, 0) with the color red
              img.update_pixel(0, 0, 255, 0, 0);
            
              // Check that the pixel at position (0, 0) has been updated correctly
              int* image_data = img.get_image_data();
              EXPECT_EQ(image_data[0], 255);
              EXPECT_EQ(image_data[1], 0);
              EXPECT_EQ(image_data[2], 0);
            
              // Update the pixel at position (1, 1) with the color green
              img.update_pixel(1, 1, 0, 255, 0);
            
              // Check that the pixel at position (1, 1) has been updated correctly
              image_data = img.get_image_data();
              EXPECT_EQ(image_data[15], 0);
              EXPECT_EQ(image_data[16], 255);
              EXPECT_EQ(image_data[17], 0);
            }
            
            TEST(ImageTest, UpdatePixelOutOfBounds) {
              // Create an Image object with width and height of size one
              Image img(1, 1);
            
              // Try to update a pixel out of bounds
              ASSERT_DEATH(img.update_pixel(2, 2, 255, 255, 255), "");
            }
            
        </code></pre>

        Here is the Makefile:
        <pre><code>
            CXX = g++
            #CXX = clang++ # tends to give better error messages
            CXXFLAGS=--std=c++14 
            HEADERS = $(wildcard *.hpp)
            OBJECTS = $(addsuffix .o, $(basename $(filter-out imageTest.cpp, $(wildcard *.cpp)))) complex.o poly.o
            
            all: clean compile test run format
            
            %.o: %.cpp $(HEADERS)
                $(CXX) -c $< $(CXXFLAGS)
            
            %Main: %Main.o %.o
                $(CXX) -o $@ $^ $(CXXFLAGS) $(LIBS)
            
            compile: imageMain
            
            imageMain: imageMain.o newton_fractal.o image.o complex.o poly.o
                $(CXX) -o $@ $^ $(CXXFLAGS) -lgtest -lpthread
            
            imageTest: imageTest.o image.o
                $(CXX) -o $@ $^ $(CXXFLAGS) -lgtest -lpthread -lgtest_main
                ./imageTest
            
            test: imageTest
                ./$<
            
            run: imageMain
                ./$<
            
            clean:
                rm -f imageMain imageTest *.o *Main *.ppm 
            
            format:
                clang-format -i *.cpp *.hpp
            
            
            
        </code></pre>

        <pre><code>
        </code></pre>


        <section>
            <a href="#top" style="padding-left: 10px;">upwards</a>
        </section>
    </main>
    <footer>
        <address><a href="imprint.html">Imprint</a> | <a href="privacy.html">Privacy</a> | <a
                href="https://github.com/afdzlebron/22ws_bok_html_project" target="_blank">Github-Repository</a>
        </address>
    </footer>
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <script src="http://cdn.rawgit.com/noelboss/featherlight/1.7.1/release/featherlight.min.js" type="text/javascript"
        charset="utf-8"></script>

    <script type="text/javascript">
        $(function () {
            $('header a.icon').click(function () {
                $('nav').toggleClass('responsive');
            });
        });
    </script>
</body>

</html>