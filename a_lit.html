<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Literature</title>
  <!-- icon -->
  <link rel="icon" href="./img/attent.ico" />
  <!-- css -->
  <link rel="stylesheet" type="text/css" href="css/style.css" />
  <!-- Webfont -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <!-- Font Awesome -->
  <link href="./fontawesome/css/all.css" rel="stylesheet">
</head>

<body>

  <header id="top">
    <nav>
      <a href="index.html">The Attention System (ATS)</a>
      <a href="a_alr.html">Alerting</a>
      <a href="a_ort.html">Orienting</a>
      <a href="a_exe.html">Executive</a>
      <a href="a_ext.html">Extending the ATS-Framework</a>
      <a href="#">Literature</a>
      <a href="a_wks.html" target="_blank">Attention Training Workshop</a>
    </nav>
    <h1><i class="fa fa-brain"></i> Literature</h1>
  </header>

  <main>
    HERE is bdd.cpp:
    <pre><code>
#include "bdd.hpp"

#include <vector>

#include "stack.hpp"

/* ÜB 10, Aufgabe 10*/
// In bdd.cpp

AbstractNode *BDD::import_node(const Board &b, bool &already_exists) {
  Board a = b;
  a.symmetry_normalize();
  auto it = std::find_if(
      nodes.begin(), nodes.end(),
      [&a](const AbstractNode *n) { return n->configuration == a; });
  if (it != nodes.end()) {
    already_exists = true;
    return *it;
  } else {
    already_exists = false;
    // Hier entscheiden wir, ob wir einen Symmetrical_Node oder einen Dummy_Node
    // erstellen
    if (b.has_symmetries()) {
      AbstractNode *n = new Symmetrical_Node(fresh_id, b);
      ++fresh_id;
      nodes.insert(n);
      if (!root) root = n;
      return n;
    } else {
      AbstractNode *n = new Dummy_Node(fresh_id, b);
      ++fresh_id;
      nodes.insert(n);
      if (!root) root = n;
      return n;
    }
  }
}

void BDD::connect(AbstractNode *parent, AbstractNode *children, bool if_true) {
  if (if_true)
    parent->if_true = children;
  else
    parent->if_false = children;
}

void BDD::connect_true(AbstractNode *parent, bool if_true) {
  if (if_true)
    parent->if_true = true_node;
  else
    parent->if_false = true_node;
}

void BDD::connect_false(AbstractNode *parent, bool if_true) {
  if (if_true)
    parent->if_true = false_node;
  else
    parent->if_false = false_node;
}

int BDD::count_true_path() const {
  std::vector<AbstractNode *> queue(1);  // initialize with capacity 1
  int path = 0;
  if (!root) return 0;
  queue.push_back(root);  // use push_back instead of push
  while (!queue.empty()) {
    AbstractNode *b = queue.back();  // use back instead of top
    queue.pop_back();                // use pop_back instead of pop
    if (b == true_node) {
      ++path;
      continue;
    }
    if (b == false_node) continue;
    queue.push_back(b->if_true);   // use push_back instead of push
    queue.push_back(b->if_false);  // use push_back instead of push
  }
  return path;
}

int BDD::count_fundamental_true_path() const {
  std::vector<AbstractNode *> queue(1);  // initialize with capacity 1
  int path = 0;
  if (!root) return 0;
  queue.push_back(root);  // use push_back instead of push
  while (!queue.empty()) {
    AbstractNode *b = queue.back();  // use back instead of top
    queue.pop_back();                // use pop_back instead of pop
    if (b->to_delete) continue;
    b->to_delete = true;
    if (b == true_node) {
      ++path;
      continue;
    }
    if (b == false_node) continue;
    queue.push_back(b->if_true);   // use push_back instead of push
    queue.push_back(b->if_false);  // use push_back instead of push
  }
  for (auto &n : nodes) {
    n->to_delete = false;
  }
  return path;
}

std::ostream &operator<<(std::ostream &stream, const BDD &bdd) {
  std::vector<AbstractNode *> queue;
  if (bdd.root) queue.push_back(bdd.root);
  const std::string true_name("true");
  const std::string false_name("false");
  stream << "digraph BDD\n {";
  for (const auto &node : bdd.nodes) {
    assert(!node->to_delete);
    stream << node->id << "[fontname=\"Comic Mono\",label= \"" << *node
           << "\"]\n";
  }
  for (const auto &b : bdd.nodes) {
    stream << b->id << " -> ";
    if (b->if_true != bdd.true_node && b->if_true != bdd.false_node)
      stream << b->if_true->id << ";\n";
    else
      stream << (b->if_true == bdd.true_node ? true_name : false_name) << ";\n";
    stream << b->id << " -> ";
    if (b->if_false != bdd.true_node && b->if_false != bdd.false_node)
      stream << b->if_false->id;
    else
      stream << (b->if_false == bdd.true_node ? true_name : false_name);
    stream << "[style=dotted]"
           << ";\n";
  }
  stream << "}";
  return stream;
}

// We implement a recursive port-order traversal of the BDD
bool BDD::is_removable(AbstractNode *b) {
  // Hier können wir den gleichen Code wie in der Musterlösung verwenden,
  // aber mit dem Unterschied, dass wir den to_delete-Flag von AbstractNodes
  // verwenden

  if (b == true_node || b == false_node) {
    return false;
  }
  if (b == nullptr) {
    return false;
  }
  bool if_true_removable = is_removable(b->if_true);
  bool if_false_removable = is_removable(b->if_false);
  if (if_true_removable) {
    connect_false(b, true);
  }
  if (if_false_removable) {
    connect_false(b, false);
  }
  if (if_true_removable && if_false_removable) {
    b->to_delete = true;
    return true;
  }
  return false;
}

// remove useless parts of the entire BDD, by checking if the root should
// be removed
void BDD::normalize_bdd() {
  /*NEW ÜB 10, Aufgabe 11*/
  /*TODO ÜB 10, Aufgabe 11*/

  // check if the root is removable and replace it with false if so
  if (is_removable(root)) {
    root = false_node;
    return;
  }

  // iterate over all nodes and delete the ones marked as to_delete
  for (auto it = nodes.begin(); it != nodes.end();) {
    AbstractNode *n = *it;
    if (n->to_delete) {
      delete n;
      it = nodes.erase(it);
    } else {
      ++it;
    }
  }
}
</code></pre>
    Here is bddMain.cpp:
    <pre><code>
#include "bdd.hpp"

int main() { BDD bdd; }</code></pre>
    Here is bddTest.cpp:
    <pre><code>
#include <fstream>
#include <gtest/gtest.h>
#include <iostream>

#include "bdd.hpp"

// In this test, we construct a simple BDD with boards of length 4 and we write
// the corresponding graph to a file.
TEST(BDDTest, basicTest) {
  // create two distinct nodes a and b
  Board a(4);
  a.next(true);
  Board b(4);
  BDD bdd;

  bool already_exists = false;
  Node *a1 = bdd.import_node(a, already_exists);

  ASSERT_TRUE(a.has_next(true));
  a.next(true);
  Node *a2 = bdd.import_node(a, already_exists);

  ASSERT_TRUE(b.has_next(false));
  b.next(false);

  Node *b2 = bdd.import_node(b, already_exists);
  bdd.connect(a1, a2, true);
  bdd.connect(a1, b2, false);
  ASSERT_EQ(a1->if_true, a2);
  ASSERT_EQ(a1->if_false, b2);
  ASSERT_EQ(bdd.root, a1);

  bdd.connect_true(a2, true);
  bdd.connect_true(a2, false);

  bdd.connect_true(b2, true);
  bdd.connect_false(b2, false);

  ASSERT_EQ(bdd.count_true_path(), 3);

  std::ofstream myfile;
  myfile.open("small_test_bdd.txt");
  if (myfile.is_open()) {
    myfile << bdd;
    myfile.close();
  }
}

int main() {
  testing::InitGoogleTest();
  return RUN_ALL_TESTS();
}
</code></pre>
    Here is board.cpp:
    <pre><code>
#include "board.hpp"

#include <assert.h>

#include <string>

bool Board::has_next(bool taken) const {
  int position_to_change = -1;
  for (int i = 0; i < size; ++i) {
    if (board[i] <= 0) {
      position_to_change = i;
      break;
    }
  }

  if (position_to_change == -1) return false;

  const int value = board[position_to_change];

  if (!taken && size == -value + 1) return false;

  return true;
}

void Board::next(bool taken) {
  int position_to_change = -1;
  for (int i = 0; i < size; ++i) {
    if (board[i] <= 0) {
      position_to_change = i;
      break;
    }
  }

  assert(position_to_change != -1);

  const int value = board[position_to_change];

  assert(taken || size != value - 1);

  if (taken)
    board[position_to_change] = -value + 1;
  else
    board[position_to_change] -= 1;
}

std::ostream &operator<<(std::ostream &stream, const Board &board) {
  for (int line = 0; line < board.size; ++line) {
    stream << "|";
    for (int row = 0; row < board.size; ++row) {
      if (board.board[row] - 1 == line)
        stream << "d";
      else if (board.board[row] < 0 && line <= -board.board[row] - 1)
        stream << ".";
      else
        stream << " ";
      stream << "|";
    }
    stream << "\n";
  }
  return stream;
}

// Checks if a position is valid: two queens are (i) on the same row if they
// have the position and (ii) are on the same diagonal if the distance is the
// same as the row distance.
bool Board::is_valid() const {
  for (int i = 0; i < size; ++i) {
    if (board[i] < 0) continue;
    if (board[i] > 0) {
      for (int j = 0; j < size; ++j) {
        if (i == j || board[j] <= 0) continue;
        if (board[i] == board[j]) {
          return false;
        }
        if (std::abs(board[i] - board[j]) == std::abs(i - j)) return false;
      }
    }
  }

  return true;
}

bool Board::is_full() const {
  for (int i = 0; i < size; ++i) {
    if (board[i] <= 0) return false;
  }

  return true;
}

bool Board::has_symmetries() const {
  // Überprüfen, ob die Dame in der ersten Hälfte der Spalte steht
  if (board[size - 1] > size / 2) {
    return true;
  }
  // Überprüfen, ob die Dame in der letzten Spalte eine niedrigere Position hat
  // als die Dame in der ersten Spalte
  if (board[size - 1] < board[0]) {
    return true;
  }
  return false;
}

void Board::horizontal_flip() {
  for (int i = 0; i < size; i++) {
    board[i] = size - board[i] - 1;
  }
}

void Board::vertical_flip() { std::reverse(board, board + size); }

void Board::symmetry_normalize() {
  if (has_symmetries()) {
    if (board[size - 1] > size / 2) {
      horizontal_flip();
    }
    if (board[size - 1] < board[0]) {
      vertical_flip();
    }
  }
}

bool Board::operator<(const Board &n) const {
  if (size != n.size) {
    return size < n.size;
  }
  for (int i = 0; i < size; i++) {
    if (board[i] != n.board[i]) {
      return board[i] < n.board[i];
    }
  }
  return false;
}

bool Board::operator<=(const Board &n) const { return *this < n || *this == n; }
</code></pre>
    Here is boardTest.cpp:
    <pre><code>
#include <gtest/gtest.h>

#include "board.hpp"

TEST(BoardTest, nextTest) {
  Board b(3);
  b.board[0] = -1;

  ASSERT_TRUE(b.has_next(true));

  b.next(true);
  ASSERT_EQ(b.board[0], 2);

  ASSERT_TRUE(b.has_next(false));
  b.next(false);
  ASSERT_EQ(b.board[0], 2);
  ASSERT_EQ(b.board[1], -1);

  ASSERT_TRUE(b.has_next(false));
  b.next(false);
  ASSERT_EQ(b.board[0], 2);
  ASSERT_EQ(b.board[1], -2);

  ASSERT_FALSE(b.has_next(false));

  ASSERT_TRUE(b.has_next(true));
  b.next(true);
  ASSERT_EQ(b.board[0], 2);
  ASSERT_EQ(b.board[1], 3);
  ASSERT_EQ(b.size, 3);

  ASSERT_TRUE(b.has_next(true));
  b.next(true);
  ASSERT_EQ(b.board[0], 2);
  ASSERT_EQ(b.board[1], 3);
  ASSERT_EQ(b.board[2], 1);
  ASSERT_EQ(b.size, 3);
}

TEST(BoardTest, stringTest) {
  Board b(3);
  b.board[0] = 3;
  b.board[1] = 1;
  b.board[2] = 2;

  std::stringstream b_position;
  b_position << b;
  ASSERT_EQ(b_position.str(), "| |d| |\n"
                              "| | |d|\n"
                              "|d| | |\n");
  b.board[0] = -3;
  b.board[1] = 1;
  b.board[2] = 2;

  std::stringstream c_position;
  c_position << b;
  ASSERT_EQ(c_position.str(), "|.|d| |\n"
                              "|.| |d|\n"
                              "|.| | |\n");
}

TEST(BoardTest, validTest) {
  Board b(4);
  b.board[0] = 3;
  b.board[1] = 1;
  b.board[2] = 4;
  b.board[3] = 2;
  ASSERT_TRUE(b.is_valid());

  b.board[3] = -2;
  ASSERT_TRUE(b.is_valid());

  b.board[3] = 1;
  ASSERT_FALSE(b.is_valid());

  b.board[0] = 1;
  b.board[1] = -1;
  b.board[2] = -4;
  b.board[3] = 4;
  ASSERT_FALSE(b.is_valid());

  b.board[0] = 4;
  b.board[1] = 2;
  b.board[2] = 0;
  b.board[3] = 0;
  ASSERT_TRUE(b.is_valid());

  b.board[0] = 4;
  b.board[1] = 1;
  b.board[2] = 0;
  b.board[3] = 0;
  ASSERT_TRUE(b.is_valid());
}

TEST(BoardTest, flipTest) {

  Board b(4);
  b.board[0] = 3;
  b.board[1] = 1;
  b.board[2] = 4;
  b.board[3] = 2;

  ASSERT_TRUE(b.has_symmetries());
  b.horizontal_flip();

  ASSERT_EQ(b.board[0], 2);
  ASSERT_EQ(b.board[1], 4);
  ASSERT_EQ(b.board[2], 1);
  ASSERT_EQ(b.board[3], 3);

  ASSERT_FALSE(b.has_symmetries());

  b.vertical_flip();
  ASSERT_EQ(b.board[0], 3);
  ASSERT_EQ(b.board[1], 1);
  ASSERT_EQ(b.board[2], 4);
  ASSERT_EQ(b.board[3], 2);

  ASSERT_TRUE(b.has_symmetries());

  b.symmetry_normalize();

  ASSERT_EQ(b.board[0], 2);
  ASSERT_EQ(b.board[1], 4);
  ASSERT_EQ(b.board[2], 1);
  ASSERT_EQ(b.board[3], 3);

  b.vertical_flip();
  ASSERT_EQ(b.board[0], 3);
  ASSERT_EQ(b.board[1], 1);
  ASSERT_EQ(b.board[2], 4);
  ASSERT_EQ(b.board[3], 2);

  b.board[3] = 0;
  ASSERT_TRUE(b.has_symmetries());

  b.board[1] = -3;
  ASSERT_FALSE(b.has_symmetries());

  b.board[1] = 1;
  b.board[4] = 0;
  ASSERT_TRUE(b.has_symmetries());

  b.board[0] = 3;
  b.board[1] = 0;
  b.board[2] = 0;
  b.board[3] = 0;

  ASSERT_TRUE(b.has_symmetries());
}

TEST(BoardTest, orderTest) {

  Board b(4);
  b.board[0] = 3;
  b.board[1] = 1;
  b.board[2] = 4;
  b.board[3] = 2;

  Board c(4);
  c.board[0] = 3;
  c.board[1] = 1;
  c.board[2] = 4;
  c.board[3] = 2;

  ASSERT_LE(b, c);
  ASSERT_FALSE(b < c);

  c.board[0] = -1;
  ASSERT_LE(c, b);
  ASSERT_LT(c, b);

  c.board[0] = 4;
  c.board[3] = 3;
  ASSERT_LE(b, c);
  ASSERT_LT(b, c);

  Board e(0);

  ASSERT_LE(e, b);
  ASSERT_LT(e, b);
}

int main() {
  testing::InitGoogleTest();
  return RUN_ALL_TESTS();
}
</code></pre>
    Here is node.cpp:
    <pre><code>
#include "node.hpp"

AbstractNode::AbstractNode(int id, const Board &config)
    : id(id), configuration(config) {}

Symmetrical_Node::Symmetrical_Node(int id, const Board &config)
    : AbstractNode(id, config) {}

Dummy_Node::Dummy_Node(int id, const Board &config)
    : AbstractNode(id, config) {}

std::ostream &operator<<(std::ostream &stream, const AbstractNode &node) {
  stream << node.configuration;
  return stream;
}
</code></pre>
    Here is nqueens.cpp:
    <pre><code>
#include "nqueens.hpp"

#include <fstream>
#include <stack>

void NQueens::check_and_add_child(Node *parent, bool direction,
                                  std::stack<Node *> &stack) {
  /*ÜB10, Aufgabe 6, optional*/
  Board b = parent->get_configuration();
  if (!b.has_next(direction)) {
    bdd.connect_false(parent, direction);
    return;
  }

  b.next(direction);
  const bool valid = b.is_valid();
  if (!valid) {
    bdd.connect_false(parent, direction);
    return;
  }
  if (b.is_full()) {
    assert(valid);
    bdd.connect_true(parent, direction);
    return;
  } else {
    bool already_exists = false;
    Node *child = bdd.import_node(b, already_exists);
    if (!already_exists) stack.push(child);
    bdd.connect(parent, child, direction);
  }
  return;
}

void NQueens::construct_bdd() {
  /*ÜB10, Aufgabe 6*/
  Board b(size);
  std::stack<Node *> stack;
  bool already_exists = false;
  Node *n = bdd.import_node(b, already_exists);
  stack.push(n);
  int next_limit = size;
  int visited_nodes = 1;
  while (!stack.empty()) {
    Node *n = stack.top();
    stack.pop();
    check_and_add_child(n, false, stack);
    check_and_add_child(n, true, stack);
    visited_nodes += 2;
    if (visited_nodes >= next_limit) {
      // NEW ÜB10
      /* ÜB 10, Aufgabe 11*/
      // This is new compared to the ÜB9
      // we reduce the BDD, in increasingly large limits.
      // I have not tried to optimize the numbers, but it seems to work more or
      // less
      //
      // ÜB10, Aufgabe 11
      next_limit *= 2;
      bdd.normalize_bdd();
    }
  }
  bdd.normalize_bdd();
}</code></pre>
    Here is nqueensMain.cpp:
    <pre><code>
#include "nqueens.hpp"

int main() {
  NQueens queens(4);
  std::cout << queens.count_solutions();
}
</code></pre>
    Here is nqueensTest.cpp:
    <pre><code>
#include <gtest/gtest.h>

#include "nqueens.hpp"

int create_nqueens_and_count(int n) {
  NQueens queens(n);
  return queens.count_solutions();
}

int create_nqueens_and_count_fundamental(int n) {
  NQueens queens(n);
  return queens.count_fundamental_solutions();
}

TEST(NQueensTest, ValueTest) {
  ASSERT_EQ(create_nqueens_and_count(4), 2);
  ASSERT_EQ(create_nqueens_and_count(5), 10);
  ASSERT_EQ(create_nqueens_and_count(6), 4);
  ASSERT_EQ(create_nqueens_and_count(7), 40);
  ASSERT_EQ(create_nqueens_and_count(8), 92);
}
TEST(NQueensTest, FundamentalSolutionsTest) {
  ASSERT_EQ(create_nqueens_and_count_fundamental(4), 1);
  ASSERT_EQ(create_nqueens_and_count_fundamental(5), 2);
  ASSERT_EQ(create_nqueens_and_count_fundamental(6), 1);
  ASSERT_EQ(create_nqueens_and_count_fundamental(7), 6);
  ASSERT_EQ(create_nqueens_and_count_fundamental(8), 12);
}

int main() {
  testing::InitGoogleTest();
  return RUN_ALL_TESTS();
}
</code></pre>
    Here is stack.cpp:
    <pre><code>
#include "stack.hpp"
#include "board.hpp"
#include "node.hpp"

template <typename T> void Stack<T>::reserve(int n) {
  if (n < capacity)
    return;

  capacity = n;
  T *nb = new T[n];
  for (int i = 0; i < size; ++i)
    nb[i] = stack[i];

  delete[] stack;
  stack = nb;
}

template <typename T> void Stack<T>::push(const T &board) {
  if (size + 1 >= capacity)
    reserve(2 * capacity);

  assert(size < capacity);
  stack[size] = std::move(board);
  ++size;
}

template <typename T> void Stack<T>::pop() {
  if (!size)
    return;
  --size;
}

template <typename T> T Stack<T>::top() const { return stack[size - 1]; }

template <typename T> bool Stack<T>::empty() const { return size == 0; }

// instantiation
template class Stack<Node *>;
template class Stack<Board *>;
template class Stack<Board>;</code></pre>
    Here is stackTest.cpp:
    <pre><code>
#include <gtest/gtest.h>

#include "board.hpp"
#include "stack.hpp"

TEST(StackTest, pushTest) {
  const Board a(4);
  const Board b(5);
  Stack<Board> s;

  ASSERT_TRUE(s.empty());
  s.push(a);
  assert(s.stack[0] == a);

  ASSERT_FALSE(s.empty());
  s.push(b);

  assert(s.stack[0] == a);
  ASSERT_EQ(s.stack[0], a);
  ASSERT_EQ(s.stack[1], b);

  const Board c = s.top();
  ASSERT_EQ(b, c);
  s.pop();

  const Board d = s.top();
  ASSERT_EQ(d, a);
  s.pop();

  ASSERT_TRUE(s.empty());
  s.pop();
  ASSERT_TRUE(s.empty());
}

int main() {
  testing::InitGoogleTest();
  return RUN_ALL_TESTS();
}
</code></pre>
    Here is bdd.hpp:
    <pre><code>
#ifndef BLATT_BDD_BDD
#define BLATT_BDD_BDD

#include <gtest/gtest.h>

#include <ostream>
#include <vector>

#include "node.hpp"

// This is a very simple implementation of a BDD (binary decision diagram).
//
// There are two special nodes `true_node' and `false_node' that represent 1 and
// 0 of the BDD.
//
// The interface is very simple in order to construct the BDD:
//
//  - it is possible to import a Board. This returns the node as imported by the
//  BDD
//
//  - Nodes can be connected via `connect_true' and `connect_false' (for
//  connection to true or
//  - false) and `connect' to connect two nodes
//
//
// Internally, all nodes are stored in the `nodes' vector in order do be able to
// destray all the nodes.
//
// NEW: internally we use the to_delete flag in nodes, but the invariant that is
// true (except within functions) is that it is always set to false.
class BDD {
 public:
  BDD() : fresh_id(0), root(nullptr) {}
  BDD(const BDD &) = delete;
  BDD(BDD &&) = delete;

  // This function imports a Board and returns a node. The successors of the
  // nodes are set to the false node automatically.
  //
  // NEW ÜB10
  // If the node has symmetries, we check if the fundamental node is already
  // present and set the already_exists parameter.
  Node *import_node(const Board &b, bool &already_exists);

  AbstractNode *import_node(const Board &b, bool &already_exists);
  
  ~BDD();

  // // destructor
  // ~BDD() {
  //   for (auto &n : nodes) {
  //     delete n;
  //   }
  // }

  friend class Node;

  // connect two nodes together
  // overwriting any existing relationships.
  void connect(AbstractNode *parent, AbstractNode *children, bool if_true);

  // connect the node to the true or false node assuming that parent is valid
  // pointer to a node (neither true nor false)
  void connect_true(AbstractNode *parent, bool if_true);
  void connect_false(AbstractNode *parent, bool if_true);

  // counts the number of paths leading to true
  int count_true_path() const;

  // count the number of fundamental paths leading to true
  /*NEW ÜB 10, Aufgabe 12*/
  int count_fundamental_true_path() const;

  // Write the graph as a dot (graphviz) file.
  friend std::ostream &operator<<(std::ostream &stream, const BDD &bdd);

  // normalization of the BDD by getting rid of of the paths to false
  void normalize_bdd();

 private:
  // we number of nodes starting from 0 upwards.
  int fresh_id;

  // Root node. If our BDD contains any node, then one of them is the root file.
  AbstractNode *root;

  // This are two specific nodes, true or false. These nodes have a specific
  // meaning and should not be seen as nodes that can be dereferenced.
  AbstractNode *const true_node = (AbstractNode *)1;
  AbstractNode *const false_node = (AbstractNode *)2;

  // checks if all the nodes are going to false. In this case, the function
  // returns true and replace the children of the parameter by false_node.

  bool is_removable(AbstractNode *);

  struct NodeCmp {
    bool operator()(AbstractNode *const &lhs, AbstractNode *const &rhs) const {
      return *lhs < *rhs;
    }
  };

  // A list of all nodes within the class sorted.  It is necessary to define the
  // ordering. Otherwise, the ordering on pointers is used (very painful
  // debugging experience).
  // NEW ÜB10: changed from an unsorted vector to a (sorted) set for efficient
  // search.
  std::set<AbstractNode *, NodeCmp> nodes;

  FRIEND_TEST(BDDTest, basicTest);
};

#endif</code></pre>
    Here is board.hpp:
    <pre><code>
#ifndef BLATT_BDD_BOARD
#define BLATT_BDD_BOARD

#include <gtest/gtest.h>

#include <cstdio>
#include <string>

// Representation of a configuration for our n-queens
// problem and iteration over all positions.
//
// Our class internally uses an array of int of a given size, where each int
// means:
//   - == 0 no queens in this column
//   - <0 no queen up to that position
//   - >0 the only queen is at that position.
//
// The board is already tailored toward our needs by disallowing 2 queens in
// this column. We also are using a fixed size.
//
// For each board, there are at most two successors: either the queen is at the
// next empty position (the column value was <= 0 and has now value > 0) or it
// is not (the column value was <=0 and is now decreased by 1).
class Board {
public:
  Board() : size(0), board(nullptr) {}

  Board(int n) : size(n) {
    board = new int[n];
    for (int i = 0; i < n; ++i)
      board[i] = 0;
  }

  Board(const Board &pos) {
    size = pos.size;
    board = new int[size];
    for (int i = 0; i < size; ++i)
      board[i] = pos.board[i];
  }

  Board(Board &&pos) {
    size = pos.size;
    board = pos.board;
    pos.size = 0;
    pos.board = nullptr;
  }

  Board operator=(const Board &pos) {
    delete[] board;
    size = pos.size;
    board = new int[size];
    for (int i = 0; i < size; ++i)
      board[i] = pos.board[i];
    return *this;
  }

  Board operator=(Board &&pos) {
    size = pos.size;
    board = pos.board;
    pos.size = 0;
    pos.board = nullptr;
    return *this;
  }

  ~Board() { delete[] board; }

  bool operator==(const Board &b) const {
    if (size != b.size)
      return false;
    for (int i = 0; i < size; ++i) {
      if (board[i] != b.board[i])
        return false;
    }
    return true;
  }

  // checks if this position has a next position
  bool has_next(bool taken) const;

  // changes the current position to the next one
  // assuming that there is one
  void next(bool taken);

  // give a board as a string with '|' separating the cells with 'D' for queens
  // and when there is no queen, it prints '.' for positions where there is no
  // queen. For example |D|.|_|
  // |_|.|_|
  // |_| |_|
  // here the queen in the second column can only be at the very bottomx.
  friend std::ostream &operator<<(std::ostream &stream, const Board &board);

  // checks if the current board is compatible with the rules
  bool is_valid() const;

  // checks if the current board is compatible with the rules
  bool is_full() const;

  bool has_symmetries() const;
  void symmetry_normalize();

  // precondition: no negative numbers!
  void horizontal_flip();
  void vertical_flip();

  // Shortlex order on the elements on the board.
  // Negative entries are considered as negative numbers.
  /*NEW ÜB 10, Aufgabe 9*/
  bool operator<(const Board &n) const;

  // Shortlex order on the elements on the board
  // Negative entries are considered as negative numbers.
  /*NEW ÜB 10, Aufgabe 9*/
  bool operator<=(const Board &n) const;

private:
  int size;
  int *board;
  FRIEND_TEST(BoardTest, nextTest);
  FRIEND_TEST(BoardTest, stringTest);
  FRIEND_TEST(BoardTest, validTest);
  FRIEND_TEST(BoardTest, flipTest);
  FRIEND_TEST(BoardTest, orderTest);
};

#endif
</code></pre>
    Here is node.hpp:
    <pre><code>
#ifndef BLATT_BDD_NODE
#define BLATT_BDD_NODE

#include <gtest/gtest.h>

#include "board.hpp"

class AbstractNode {
 public:
  int id;
  Board configuration;
  AbstractNode *if_true;
  AbstractNode *if_false;
  bool to_delete;
  AbstractNode(int id, const Board &config);
  virtual ~AbstractNode() {}
  bool operator<(const AbstractNode &rhs) const {
    return configuration < rhs.configuration;
  }
};

class Symmetrical_Node : public AbstractNode {
 public:
  Symmetrical_Node(int id, const Board &config);
};

class Dummy_Node : public AbstractNode {
 public:
  Dummy_Node(int id, const Board &config);
};

std::ostream &operator<<(std::ostream &stream, const AbstractNode &node);

// Node in the BDD
//
// It contains 2 informations, the position and an id to help debugging
// We initialize the successor to be the null pointer.
class Node {
 public:
  // NEW ÜB10: make it clear that initialized with nullptr
  Node(int fresh_id, const Board &config)
      : id(fresh_id),
        configuration(config),
        if_true(nullptr),
        if_false(nullptr) {}
  Node(int fresh_id, Board &&config)
      : id(fresh_id),
        configuration(config),
        if_true(nullptr),
        if_false(nullptr) {}

 public:
  // identifier used whenever we need a number or something to distinguish it
  // from other nodes.
  const int id;

  // brind the content of
  friend std::ostream &operator<<(std::ostream &stream, const Node &bdd);

  // returns a copy of the configuration
  Board get_configuration() const { return configuration; };

 private:
  Board configuration;

 public:
  // connection to the two successors when taken and when not taken
  Node *if_true;
  Node *if_false;

  // to_delete to indicate some information on the node
  // we use this in various cases
  // by default the value is false
  bool to_delete = false;

  bool operator==(const Node &n) const {
    return configuration == n.configuration;
  }

  bool operator<(const Node &n) const {
    return configuration < n.configuration;
  }

  bool operator<=(const Node &n) const {
    return configuration <= n.configuration;
  }
};

#endif</code></pre>
    Here is nqueens.hpp:
    <pre><code>
#ifndef BLATT_BDD_NQUEENS
#define BLATT_BDD_NQUEENS

#include <stack>

#include "bdd.hpp"

class NQueens {
public:
  NQueens(int n) : size(n) { construct_bdd(); }

  // counts the number of solutions to the nqueens problems.
  // Assumes that the construction is finished
  int count_solutions() { return bdd.count_true_path(); }

  // counts the number of fundamental solutions to the nqueens problems.
  // Assumes that the construction is finished
  /*NEW ÜB 10, Aufgabe 12*/
  int count_fundamental_solutions() {
    return bdd.count_fundamental_true_path();
  }

private:
  // construct the internal representation of the n-queens problem
  void construct_bdd();

  // connect parent to its child (true or false depending on direction) and
  // pushing the node to the stack
  void check_and_add_child(Node *parent, bool direction,
                           std::stack<Node *> &stack);
  int size;
  BDD bdd;
};
#endif</code></pre>
    Here is stack.hpp:
    <pre><code>
#ifndef BLATT_BDD_STACK
#define BLATT_BDD_STACK

#include <gtest/gtest.h>

#include "board.hpp"

template <typename T> class Stack {
public:
  Stack() : size(0), capacity(1), stack(nullptr) {}

  ~Stack() { delete[] stack; }

  // push the element to the stack
  void push(const T &pos);

  // last element added
  T top() const;

  // deletes the last inserted element of the stack
  void pop();

  // checks if the stack is empty
  bool empty() const;

  // resize to match the capacity if required
  void reserve(int n);

  const T operator[](int n) const { return stack[n]; }

  int number_of_elements() const { return size; }

private:
  int size;
  int capacity;
  T *stack;

  FRIEND_TEST(StackTest, pushTest);
};

#endif
</code></pre>

  </main>

</body>

</html>